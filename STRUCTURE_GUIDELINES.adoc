# BiliPai 结构维护准则

适用范围：`app/src/main/java/com/android/purebilibili/`

## 1. 分层边界

- `app/`：应用入口、启动初始化、全局装配。
- `core/`：跨业务公共能力，不包含具体业务场景。
- `data/`：数据获取与存储实现（repository/model）。
- `domain/`：稳定业务规则（usecase）。
- `feature/`：按业务场景组织的 UI 与交互实现。
- `navigation/`：全局路由和页面注册。

## 2. 目录归属规则

- 公共逻辑优先放 `core/`，不要放在某个 `feature/*` 后再被多处复用。
- 业务页面、业务状态和业务交互放 `feature/<name>/`。
- 若同一功能子域文件超过 5 个，拆子目录：
  - `screen/`：页面组合与布局。
  - `viewmodel/`：状态管理与事件处理。
  - `policy/`：纯策略函数（无 Android 依赖）。
  - `service/`：对外部系统或 I/O 的封装。
- 同一领域（例如 WebDAV）集中到单独子包，如：`feature/settings/webdav/`。

## 3. 依赖方向（必须满足）

- `feature -> domain -> data -> core`（允许跨过某层读取，但禁止反向依赖）。
- `core` 不能依赖任何 `feature/*`。
- 禁止 `feature/A` 直接依赖 `feature/B` 的 UI 组件。
- 跨 feature 共享能力应先下沉到 `core` 或 `domain`。

## 4. 命名与可读性约束

- 包名使用单数语义：`util`（不再新增 `utils`）。
- 策略类统一后缀：`*Policy`。
- 页面类统一后缀：`*Screen`。
- 状态容器统一后缀：`*State`。
- ViewModel 统一后缀：`*ViewModel`。

## 5. 新增代码前检查清单

1. 这个文件是否会被两个以上 feature 复用？如果会，先考虑放到 `core/`。
2. 是否引入了反向依赖（低层依赖高层）？
3. 当前目录是否已过载（根目录文件过多）？必要时先拆子目录。
4. 是否补充了对应测试（至少 policy/usecase 级）？
5. 是否需要同步 README 结构说明？

## 6. 渐进式治理顺序

1. 优先收敛“公共能力误放 feature”问题。
2. 再处理“单目录文件过多”的子目录拆分。
3. 最后推进 Gradle 多模块拆分（避免一次性大重构）。

